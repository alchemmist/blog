---
tech_name: typing-python
title: Типизация в Python
date: '2026-02-11T16:02:00+03:00'
language: ru
description: В этой статье рассматривается два ключевых вопроса. Зачем использовать
  типизацию в языке Python, который позволяет писать без неё? И как писать типизированный
  код на Python правильно? Постараемся быстро познакомится со всеми необходимыми инструментами,
  чтобы после прочтения вы уже могли начать пиать свои программы типизированными,
  ведь это совсем не сложно!
tags:
- python
- eosp
extra:
  custom_props:
    public: true
    type: synopsis
    theme: other
    status: finished
---

В этой статье рассматривается два ключевых вопроса. Зачем
использовать типизацию в языке Python, который позволяет писать
без неё? И как писать типизированный код на Python правильно?
Постараемся быстро познакомится со всеми необходимыми
инструментами, чтобы после прочтения вы уже могли начать
осознанно пиать свои программы типизированными, ведь это совсем
не сложно!

## Динамика vs Статика

Итак, что же такое типизация? Новым это понятие может оказаться
только для питонистов, ведь большинство классических языков таких
как C, Java, Rust и многие другие исходно были созданы, как языки
со статической типизацей. Но что это означает? Давайте рассмотрим
небольшой пример на C:

```c
int sum(int a, int b) {
    return a + b;
}

int main() {
    printf("%d\n", sum(10, 20));

    // printf("%d\n", sum("10", 20));
}
```

Такой код работает и выводит число `30`. Но обратите внимание,
что последняя строка закомментированна. Если мы раскомментируем
её и опять попробуем скомпилировать программу, то получим
примерно вот такой лог ошибки: 

```plaintext
error: passing argument 1 of ‘sum’ makes integer from pointer without cast
   10 |     printf("%d\n", sum("10", 20));
      |                        ^~~~
      |                        |
      |                        char *
note: expected ‘int’ but argument is of type ‘char *’
```

Он сообщает нам, что параметр функции, ожидая `int`, получил
аргумент типа `char *` (_для упрощения можем считать это
эквивалентом строки_). На первый взгляд ничего удивительного, для
нас с вами — питонистов, в этом нет. Ведь вот такой код на
Python, тоже упал бы с ошикбой:

```python
def sum(a, b):
    return a + b

print(sum("10", 20)) # TypeError
```

В чем же разнциа, спросите вы? Давайте немного подправим оба этих
примера на C и на Python. Попробуем вызвать функцию `sum` от двух
строк:

```python
print(sum("10", "20")) # > 1020
```

Здесь мы не получаем никаких ошибок, потому что действует
полиморфизм, а для строк операция сложения тоже реализована. Но
что будет в C?

```c
int main() {
    printf("%d\n", sum("10", "20"));
}
```

Но такую программу не выйдет даже скомпилировать. Мы опять
получим точно такой же лог ошибки, который был ранее. Обратите
внимание на то, как мы определяли функцию `sum` в языке C. Там мы
явно указали типы входных аргументов как `int`. Это означает, что
аргумент любого другого типа нельзя передать в эту функцию. Это
и называется статической типизаций. Так же статическая типизация
обязывает указать тип для каждой перменной и запрещяет менять
типы перменных после определния оных. То есть тип фиксирован,
статичен.

Вторя же группа языков называятеся динамически типизированными.
Это такие языки как Python, Lua, JavaScript и другие. В них,
соответственно, тип перменной строго не фиксирован и может
менятся в ходе исполнения программы.

## Приемущества типизации

Пора перейти к вопросу, зачем типизация нам нужно если в том же
Python всё и так работает отлично. Во-первых, это сокрость. На
низком уровне (_чем бы он ни был представлен_) нам в любом случае
нужно знать типы переменных. А тот факт, что мы можем позволить
себе, их не ввыствлять, лишь означает, что кто-то делает это за
нас (_например вирутальная машина_), а это в свою очередь требует
больших ресурсов. Отсюда и картина, которую мы наблюдаем
в рейтингах языков по скорости:

![|600](/images/pl-rating.png)

Python в этом
[рейтинге](https://github.com/niklas-heer/speed-comparison),
кстати говоря, на последнем месте. Может быть типизированный
Python как раз поможет нам исправить этот печальный факт?
К сожалению, нет. Поскольку Python, как не был исхоно, так по сей
день остается, **не** статически типизированным языком.

Тут мы переходим ко второму приемуществу, которое отркывают для
нас типы. И это качество кода.

> Цель типизации в Python — помочь инструментам разработки искать
> ошибки в кодовых базах на Python с помощью статического
> анализа, то есть не выполняя тестов кода. 
>
> Лусиану Рамальо, «Python. К вершинам мастерства»

Расширяя эту мысль, мы можем уточнить, что цели типизации это:

- Раннее выявление ошибок — до runtime-а, до падения кода на
  продакшене
- "Экстракция" тестов — правльная типизаця помогает уменьшить
  количество тестов, писать и поддерживать которые сожнее, чем
  типы. В тестах остаётся тестировать бизнес логику, а не
  банальное несоответствие примитовов.
- Улучшение читаемости кода — [PEP
  20](https://peps.python.org/pep-0020/) говорит нам о том, что
  "явное лучше неявного". Когда мы читаем код, нам достаточно
  увидить сигнатуру функции, не вчитываясь в её реализацию
- Упрощение разработчки в IDE / PDE — большое подсказок
  и предупреждений о потенциальных ошибках.
- Повышение качества архитектуры — типы "заставляют"
  проектировать правильные абсатрации.


